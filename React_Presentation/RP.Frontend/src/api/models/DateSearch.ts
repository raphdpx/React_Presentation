// tslint:disable
// eslint-disable
/**
 * PaulExpress API v1.0
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from "../runtime";
import {
  ECriteriaType,
  ECriteriaTypeFromJSON,
  ECriteriaTypeFromJSONTyped,
  ECriteriaTypeToJSON,
  EDateSearchType,
  EDateSearchTypeFromJSON,
  EDateSearchTypeFromJSONTyped,
  EDateSearchTypeToJSON
} from "./";

/**
 *
 * @export
 * @interface DateSearch
 */
export interface DateSearch {
  /**
   *
   * @type {ECriteriaType}
   * @memberof DateSearch
   */
  typeOfCriteria?: ECriteriaType;
  /**
   *
   * @type {EDateSearchType}
   * @memberof DateSearch
   */
  searchMode?: EDateSearchType;
  /**
   *
   * @type {Date}
   * @memberof DateSearch
   */
  value?: Date | null;
  /**
   *
   * @type {Date}
   * @memberof DateSearch
   */
  secondaryValue?: Date | null;
  /**
   *
   * @type {Array<string>}
   * @memberof DateSearch
   */
  readonly availableSearchTypes?: Array<string> | null;
  /**
   *
   * @type {string}
   * @memberof DateSearch
   */
  readonly currentSearchType?: string | null;
  /**
   *
   * @type {boolean}
   * @memberof DateSearch
   */
  manualSearch?: boolean;
}

export function DateSearchFromJSON(json: any): DateSearch {
  return DateSearchFromJSONTyped(json, false);
}

export function DateSearchFromJSONTyped(json: any, ignoreDiscriminator: boolean): DateSearch {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    typeOfCriteria: !exists(json, "typeOfCriteria") ? undefined : ECriteriaTypeFromJSON(json["typeOfCriteria"]),
    searchMode: !exists(json, "searchMode") ? undefined : EDateSearchTypeFromJSON(json["searchMode"]),
    value: !exists(json, "value") ? undefined : json["value"] === null ? null : new Date(json["value"]),
    secondaryValue: !exists(json, "secondaryValue")
      ? undefined
      : json["secondaryValue"] === null
      ? null
      : new Date(json["secondaryValue"]),
    availableSearchTypes: !exists(json, "availableSearchTypes") ? undefined : json["availableSearchTypes"],
    currentSearchType: !exists(json, "currentSearchType") ? undefined : json["currentSearchType"],
    manualSearch: !exists(json, "manualSearch") ? undefined : json["manualSearch"]
  };
}

export function DateSearchToJSON(value?: DateSearch | null): any {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    typeOfCriteria: ECriteriaTypeToJSON(value.typeOfCriteria),
    searchMode: EDateSearchTypeToJSON(value.searchMode),
    value: value.value === undefined ? undefined : value.value === null ? null : value.value.toISOString(),
    secondaryValue:
      value.secondaryValue === undefined
        ? undefined
        : value.secondaryValue === null
        ? null
        : value.secondaryValue.toISOString(),
    manualSearch: value.manualSearch
  };
}
